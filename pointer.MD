c언어 포인터
포인터에서 *를 쓰는 경우는 단 두 가지 
1.포인터 변수의 선언  2. 역참조

int *b = ~~일 경우: 포인터 선언
*b = a일 경우: 역참조

포인터를 쓰는 이유: 예를 들어 c언어에서 변수 x와 y의 값을 바꾸려 할 때, swap(int x ,int y)를 써도 매개변수에서 값을 
복사해 와서 바꾼 다음에 swap변수 내부에서 바꾸므로 바뀐 x와 y값은 지역변수이다. 그러므로 x와 y를 출력하고 swap함수에 x와 y를
대입한 후 다시 x와 y를 출력해도 지역변수는 함수가 끝날 때 초기화되므로 값이 변하지 않는 문제점이 있다.

위의 main()에서 swap()함수를 호출하면서 swap함수에 매개변수를 넘겨줄 때 x와 y의 값이 swap함수에 복사되고, 이렇게 함수 호출을 하면서 값을 전달하는 방식을 값에 의한 호출(Call by Value)이라고 한다.

이와 같은 문제를 해결하기 위해서 main()함수에서 호출할 때 값을 넘겨주는 것이 아니라 주소를 넘겨주는 방법을 사용한다면 이 문제를 해결할 수 있고, 이 주소를 넘겨주는 방식이 포인터를 응용한 역참조이다. 

main()함수에서 x와 y의 값이 아니라 &x, &y와 같이 주소를 swap함수에 전달한다.이때 swap함수의 두 매개변수는 주소를 저장할 수 있는 포인터여야만 한다. 그리고 이때 swap()함수의 포인터 변수 x,y는 각각 main()함수 안의 변수 x, y를 가리킨다.
이렇게 main()함수에서 값이 아닌 주소를 swap()함수에 전달하는 방식을 주소에 대한 호출(Call by Reference)이라고 한다.

함수와 함수 사이에 값을 주고받을 때 포인터를 이용해서 주고받으면 변수 그 자체가 복사되는 게 아니라 변수의 메모리 주소가 복사된다.
그러므로 주소를 전달받은 함수 안에서 전달된 주소가 가리키는 값, 즉 함수를 호출한 곳의 변수 값을 변경할 수 있다.

배열의 첫 번째 주소의 이름은 배열의 이름과 같다.

배열의 주소값을 연산할 때 +1은 주소 값에 +1이 되는 게 아니라 1byte가 증가한다는 뜻이므로 원래 주소 값 + 4 가 된다.
(정수열 배열에 한정함. 문자열 배열일 경우에는 평범하게 +1이 됨)